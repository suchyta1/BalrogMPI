#!/usr/bin/env python

import sys
import os
import numpy as np
import desdb
import copy
import socket
import logging
import json
import multiprocessing
import shutil
import esutil

import RunBalrog as runbalrog
import balrog as balrogmodule


def SendEmail(config, file):
    if config['email'] is None:
        return

    import smtplib
    from email.mime.text import MIMEText
    
    sender = config['email']
    receivers = [sender]
    msg = MIMEText( "Balrog configured in %s finished. \n \n--Message automatically generated by Balrog." %(file) )
    msg['Subject'] = '%s completed' %(config['dbname'])
    msg['From'] = sender
    msg['To'] = sender
    
    obj = smtplib.SMTP('localhost')
    obj.sendmail(sender, receivers, msg.as_string())


def GetFiles2(config):
    tiles = np.array(config['tiles'], dtype='|S12')
    df = desdb.files.DESFiles(fs='net')
    bands = runbalrog.PrependDet(config['run'])
    conn = desdb.connect()

    images = []
    psfs = []
    bs = []
    skipped = []
    usetiles = []

    for i in range(len(tiles)):
        for j in range(len(bands)):

            band = bands[j]

            if band=='det':
                d = conn.quick("SELECT c.run from coadd c, runtag rt where rt.run=c.run and c.tilename='%s' and rt.tag='%s' and c.band is null" %(tiles[i], config['run']['release'].upper()), array=True )
            else:
                d = conn.quick("SELECT c.run from coadd c, runtag rt where rt.run=c.run and c.tilename='%s' and rt.tag='%s' and c.band='%s'" %(tiles[i], config['run']['release'].upper(), band), array=True )
           
            if len(d)==0:
                if band=='det':
                    skipped.append(tiles[i])
                    break
                else:
                    continue

            if j==0:
                usetiles.append(tiles[i])
                psfs.append([])
                images.append([])
                bs.append([])

            run = d[0]['run']
            img = df.url('coadd_image', coadd_run=run, tilename=tiles[i], band=band)
            images[-1].append(img)
            psfs[-1].append(img.replace('.fits.fz', '_psfcat.psf'))
            bs[-1].append(band)

    return [images, psfs, usetiles, bs, skipped]
            

def WaitExistence(RunConfig, runlog):
    cur = desdb.connect()
    user = cur.username
   
    donenum = 4
    runlog.info('Making sure that the tables I need exist, and waiting for the first process if necessary...')
    while True:
        if os.path.exists(RunConfig['failfile']):
            raise Exception("The first process failed, Doesn't matter if DBs exist. Exiting.")
        count = 0
        arr = cur.quick("select table_name from dba_tables where owner='%s'" %(user.upper()), array=True)
        tables = arr['table_name']
        for  kind in ['truth', 'nosim', 'sim', 'des']:
            tab = 'balrog_%s_%s' %(RunConfig['dbname'], kind)
            if (tab.upper() in tables):
                count += 1
        if count==donenum:
            break
    runlog.info('Ok')


def CheckDup(RunConfig, runlog):
    done = False
    ok, fail, exit = GetSubFiles(config['run'])
    runlog.info("Making sure I can continue based your duplicate settings...")
    while not done:
        okcount = 0
        for i in range(RunConfig['nodes']):
            if os.path.exists(fail[i]):
                raise Exception('Found that subjob %i had duplicates, and you gave duplicate=error. Exiting.'%(i+1))
            if os.path.exists(ok[i]):
                okcount += 1
        if okcount==RunConfig['nodes']:
            done = True

    if os.path.exists(RunConfig['failfile']):
        raise Exception("The first process failed in a way which has nothing to do with duplicates, but I'm still exiting.")
    runlog.info('Ok')



# Delete the existing DB tables for your run if the names already exist
def DropTablesIfNeeded(RunConfig, indexstart, size, tiles, runlog):
    allbands = runbalrog.GetAllBands()
    cur = desdb.connect()
    user = cur.username

    arr = cur.quick("select table_name from dba_tables where owner='%s'" %(user.upper()), array=True)
    tables = arr['table_name']
    kinds = ['truth', 'nosim', 'sim', 'des']

    write = False
    test = 'balrog_%s_%s' %(RunConfig['dbname'], kinds[0])
    exists = (test.upper() in tables)
    
    if not RunConfig['DBoverwrite']:
        if exists:
            if RunConfig['duplicate'] == 'replace':
                runlog.info("Replacing existing entries in DB which match this run's balrog_indexes, if necessary...")
                for i in range(len(tiles)):
                    for kind in kinds[0:3]:
                        tab = 'balrog_%s_%s' %(RunConfig['dbname'], kind)
                        q = "delete from %s where tilename='%s' and balrog_index>=%i and balrog_index<%i"%(tab,tiles[0],indexstart[i],indexstart[i]+size[i])
                        arr = cur.quick(q, array=True)
                cur.commit()
                runlog.info("Done")

            if RunConfig['duplicate'] == 'error':
                runlog.info("Verifying no duplicate balrog_indexes...")
                for i in range(len(tiles)):
                    arr = cur.quick("select balrog_index from %s where tilename='%s'"%(test,tiles[i]), array=True)
                    this = np.arange(indexstart[i], indexstart[i]+size[i], 1)
                    inboth = np.in1d(np.int64(this), np.int64(arr['balrog_index']))
                    if np.sum(inboth) > 0:
                        open(RunConfig['dupfailfile'],'a').close()
                        raise Exception("You are trying to add balrog_index(es) which already exist, and you've flagged duplicate=error. Killing the subjob")
                runlog.info("Ok")

        else:
            if RunConfig['isfirst']:
                write = True

    elif (not RunConfig['isfirst']):
        runlog.info("You gave DBoverwrite=True. I'm waiting for the first process, to ensure that the %s tables have been deleted."%(RunConfig['dbname']))
        while True:
            if os.path.exists(RunConfig['failfile']):
                raise Exception("The first process failed before we can be sure that the DB is as we want it.")
            if os.path.exists(RunConfig['touchfile']):
                break

    else:
        write = True
        if exists:
            runlog.warning("You gave DBoverwrite=True, and %s exists. I'm going to remove tables.'"%(RunConfig['dbname']))
            for kind in kinds:
                tab = 'balrog_%s_%s' %(RunConfig['dbname'], kind)
                cur.quick("DROP TABLE %s PURGE" %tab)
                runlog.warning("Deleted %s"%(tab))
        open(RunConfig['touchfile'],'a').close()

    open(RunConfig['dupokfile'],'a').close()
    return write


def InitCommonToTile(tile,images,psfs,indexstart,bands, config):
        derived = {'images': images,
                   'psfs': psfs,
                   'indexstart': indexstart,
                   'db': config['db'],
                   'imbands': bands}
        if config['run']['fixwrapseed'] != None:
            derived['seedoffset'] = config['run']['fixwrapseed']
        else:
            derived['seedoffset'] = np.random.randint(10000)

        balrog = copy.copy(config['balrog'])
        balrog['tile'] = tile

        return derived, balrog

def TileIterations(tile,images,psfs,indexstart,bands,pos, config, write):
    derived, balrog = InitCommonToTile(tile,images,psfs,indexstart,bands, config)

    workingdir = os.path.join(config['run']['outdir'], balrog['tile'] )
    derived['workingdir'] = workingdir
    derived['indir'] = os.path.join(workingdir, 'input')
    runbalrog.Mkdir(derived['indir'])

    iterations = len(pos) / balrog['ngal']
    if ( len(pos) % balrog['ngal'] ) != 0:
        iterations += 1

    itQ = []
    posQ = []

    if write:
        itQ.append(-2)
        posQ.append(None)

    '''
    if RunConfig['doDES']:
        for k in range(len(band)):
            itQ.append( (-1, k) )
            posQ.append(None)
    '''

    for j in range(int(iterations)):
        start = j * balrog['ngal']
        if j==(iterations-1):
            stop = len(pos)
        else:
            stop = start + balrog['ngal']
        itQ.append(j)
        posQ.append(pos[start:stop])

    return derived, balrog, posQ, itQ


def GetPos(RunConfig, tiles):
    pos = []
    ind = []
    size = []
    for tile in tiles:
        f = os.path.join(RunConfig['pos'], '%s.fits'%(tile))
        data, header = esutil.io.read(f, header=True)
        indexstart = header['istart']
        ind.append(indexstart)

        if RunConfig['downsample'] is None:
            s = len(data)
        else:
            s = RunConfig['downsample']
        size.append(s)

        d = np.zeros( (s,2) ) 
        d[:, 0] = data['ra'][0:s]
        d[:, 1] = data['dec'][0:s]
        pos.append(d)
    return pos, ind, size


def run_balrog(args):
    RunConfig, BalrogConfig, DerivedConfig = args
    it = runbalrog.EnsureInt(DerivedConfig)

    host = socket.gethostname()
    ild = os.path.join(DerivedConfig['itlogdir'], BalrogConfig['tile'])
    DerivedConfig['itlogfile'] = os.path.join(ild, '%i.log'%it)
    if RunConfig['command']=='popen':
        DerivedConfig['itlog'] = runbalrog.SetupLog(DerivedConfig['itlogfile'], host, '%s_%i'%(BalrogConfig['tile'],it), stream=True)
    elif RunConfig['command']=='system':
        DerivedConfig['itlog'] = DerivedConfig['itlogfile']
    DerivedConfig['setup'] = balrogmodule.SystemCallSetup(retry=RunConfig['retry'], redirect=DerivedConfig['itlog'], kind=RunConfig['command'], useshell=RunConfig['useshell'])


    try:
        if it==-2:
            # Minimal Balrog run to create DB tables
            runbalrog.RunOnlyCreate(RunConfig, BalrogConfig, DerivedConfig)

        elif it==-1:
            # No simulated galaxies
            runbalrog.RunDoDES(RunConfig, BalrogConfig, DerivedConfig)
        else:
            # Actual Balrog realization
            runbalrog.RunNormal2(RunConfig, BalrogConfig, DerivedConfig)

        if RunConfig['intermediate-clean']:
            if it < 0:
                shutil.rmtree(BalrogConfig['outdir'])
            else:
                for band in DerivedConfig['bands']:
                    dir = os.path.join(DerivedConfig['outdir'], band)
                    shutil.rmtree(dir)
    except:
        msg = 'Problem running iteration %s of tile %s'%(str(DerivedConfig['iteration']),BalrogConfig['tile'])
        balrogmodule.SysInfoPrint(DerivedConfig['setup'], msg, level='error')
        balrogmodule.RaiseException(None, fulltraceback=True, sendto=DerivedConfig['setup'], message='Getting traceback inside Pool')
        raise Exception(msg)


def Run_Balrog(tiles,images,psfs,indexstart,bands,pos, config, write, runlogdir, runlog):

    for i in range(len(tiles)):
        runlog.info('Setting up tile %s'%(tiles[i]))
        if (i==0) and write:
            dowrite = True
        else:
            dowrite = False
        Derived, Balrog, Pos, It = TileIterations(tiles[i],images[i],psfs[i],indexstart[i],bands[i],pos[i], config, dowrite)
        Derived['itlogdir'] = os.path.join(runlogdir, 'iterations')
        ild = os.path.join(Derived['itlogdir'], Balrog['tile'])
        runbalrog.Mkdir(ild)

        args = []

        if config['run']['ppn'] is not None:
            ppn = config['run']['ppn']
        else:
            ppn = multiprocessing.cpu_count()
        pool = multiprocessing.Pool(ppn)


        for j in range(len(It)):

            balrog = copy.copy(Balrog)
            derived = copy.copy(Derived)

            derived['iteration'] = It[j]
            it = runbalrog.EnsureInt(derived)
            derived['pos'] = Pos[j]
            derived['outdir'] = os.path.join(derived['workingdir'], 'output', '%i'%it)
            runbalrog.Mkdir(derived['outdir'])


            balrog['indexstart'] = derived['indexstart']
            if it >= 0:
                balrog['indexstart'] += it*balrog['ngal']
                balrog['ngal'] = len(derived['pos'])
            balrog['seed'] = balrog['indexstart'] + derived['seedoffset']

            if (j==0):
                runlog.info('Downloading tile data for tile %s'%(tiles[i]))
                setup = balrogmodule.SystemCallSetup(retry=config['run']['retry'], redirect=runlog, kind=config['run']['command'], useshell=config['run']['useshell'])
                derived['images'], derived['psfs'] = runbalrog.DownloadImages(derived['indir'], derived['images'], derived['psfs'], config['run'], setup, skip=False)
                #derived['images'], derived['psfs'] = runbalrog.DownloadImages(derived['indir'], derived['images'], derived['psfs'], config['run'], setup, skip=True)

                if (It[j]==-2):
                    derived['bands'] = runbalrog.GetAllBands()
                    runlog.info('Creating database %s'%(config['run']['dbname']))
                    run_balrog( [copy.copy(config['run']), balrog, derived] )
                else:
                    derived['bands'] = runbalrog.PrependDet(config['run'])
                    args.append( [copy.copy(config['run']), balrog, derived] )

            else:
                derived['images'], derived['psfs'] = runbalrog.DownloadImages(derived['indir'], derived['images'], derived['psfs'], config['run'], None, skip=True)
                derived['bands'] = runbalrog.PrependDet(config['run'])
                args.append( [copy.copy(config['run']), balrog, derived] )


        if not config['run']['isfirst']:
            WaitExistence(config['run'], runlog)

        runlog.info('Doing all the Balrog iterations for tile %s'%(tiles[i]))
        runlog.info('Found %i iterations'%(len(args)))
        pool.map(run_balrog, args)
        runlog.info('Finished %i iterations'%(len(args)))
        
        dir = Derived['workingdir']
        if config['run']['tile-clean'] and os.path.exists(dir):
            shutil.rmtree(dir)
            runlog.info('removed %s' %(dir) )

    '''
    dir = config['run']['outdir']
    if config['run']['tile-clean'] and os.path.exists(dir):
        shutil.rmtree(dir)
        runlog.info('removed %s' %(dir) )
    '''

def OpenRunLog(runlogdir):
    if os.path.exists(runlogdir):
        shutil.rmtree(runlogdir)
    os.makedirs(runlogdir)
    host = socket.gethostname()
    rfile = os.path.join(runlogdir, 'common.log')
    runlog = runbalrog.SetupLog(rfile, host, '%s-all'%(host), stream=True)
    return runlog



class Files:
    substr = 'subjob'
    cok = 'createok'
    cfail = 'createfail'
    dupok = 'dupok'
    dupfail = 'dupfail'
    exit = 'exit'
    json = 'config'
    runlog = 'runlog'


def GetJsonDir(run, dirname, id):
    if (run['nodes'] > 1):
        jdir = os.path.join(dirname, '%s_%i'%(Files.substr,id))
    else:
        jdir = dirname
    return jdir



def GetSubFiles(RunConfig):
    okfiles = []
    failfiles = []
    exitfiles = []

    dir = os.path.dirname(RunConfig['touchfile'])
    for i in range(RunConfig['nodes']):
        sdir = GetJsonDir(RunConfig, dir, i+1)
        okfiles.append(os.path.join(sdir, Files.dupok))
        failfiles.append(os.path.join(sdir, Files.dupfail))
        exitfiles.append(os.path.join(sdir, Files.exit))

    return okfiles, failfiles, exitfiles


def RemoveIfNeeded(runlog, *args):
    for arg in args:
        if os.path.exists(arg):
            os.remove(arg)
            runlog.info('Removed %s'%(arg))

def BlockIfExists(*args):
    for arg in args:
        while True:
            if not os.path.exists(arg):
                break

def RemoveCheckFiles(config, runlog):
    if config['run']['isfirst']:
        RemoveIfNeeded(runlog, config['run']['touchfile'], config['run']['failfile'])
    BlockIfExists(config['run']['touchfile'], config['run']['failfile'])
    RemoveIfNeeded(runlog, config['run']['dupokfile'], config['run']['dupfailfile'], config['run']['exitfile'])
    sub = GetSubFiles(config['run'])
    for s in sub:
        BlockIfExists(*s) 

if __name__ == "__main__":
    
    with open(sys.argv[1]) as jsonfile:
        config = json.load(jsonfile)
    runlogdir = config['run']['runlogdir']
    runlog = OpenRunLog(runlogdir)
    RemoveCheckFiles(config, runlog)

    try:
        images, psfs, tiles, bands, skipped = GetFiles2(config)
        pos, indexstart, size = GetPos(config['run'], tiles)
        write = DropTablesIfNeeded(config['run'], indexstart, size, tiles, runlog)
        CheckDup(config['run'], runlog)
        Run_Balrog(tiles,images,psfs,indexstart,bands,pos, config, write, runlogdir, runlog)
        exit = 0
    except:
        balrogmodule.RaiseException(runlog, fulltraceback=True, sendto=None, message='Getting traceback outside Pool')
        exit = 1
        if config['run']['isfirst']:
            open(config['run']['failfile'],'a').close()
            

    with open(config['run']['exitfile'],'w') as f:
        f.write('%i'%(exit))

    sys.exit(exit)
